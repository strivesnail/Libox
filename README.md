# LiBox: High-Performance Learned Index Data Structure

LiBox is a high-performance learned index data structure optimized for modern multi-core CPUs with SIMD support. It combines machine learning techniques with traditional indexing methods to achieve superior performance for key-value storage and retrieval operations.

## Features

- **SIMD-Optimized Operations**: Leverages AVX-512 instructions for parallel data processing
- **Learned Index**: Uses linear interpolation for fast segment location
- **Multi-Level Architecture**: Three-tier design (Segment → Box → Overflow) for efficient data organization
- **High Concurrency**: Thread-safe operations with atomic version control
- **Dynamic Splitting**: Automatic segment splitting when capacity limits are reached
- **Adaptive Partitioning**: Intelligent segment configuration generation

## Requirements

- **CPU**: x86-64 processor with AVX-512 support
- **Compiler**: GCC 7.0+ with C++20 support
- **Dependencies**: OpenMP

```bash
# Ubuntu/Debian
sudo apt-get install build-essential libomp-dev

# CentOS/RHEL
sudo yum install gcc-c++ libomp-devel
```

## Getting Started

LiBox consists of three main components:

- **libox.h**: Core learned index library with insert, search, and range query functionality
- **libox_utils.h**: Utility functions for resegment partitioning and optimization
- **partition_optimization.cpp**: Data analysis tool for generating optimal configuration files

### Build

```bash
# Clone the repository
git clone https://github.com/yourusername/libox.git
cd libox

# Build optimization tool
make all

# Build debug versions
make debug

# Clean build artifacts
make clean
```

### Step 1: Generate Configuration File (Optional)

Use the partition optimization tool to analyze your dataset and generate an optimal configuration:

```bash
# Analyze your dataset and generate configuration
./test/partition_optimization /path/to/your/dataset.csv generated_config.csv

# With optional max_box_in_segment parameter (default: 50000)
./test/partition_optimization /path/to/your/dataset.csv generated_config.csv 50000
```

Or use the provided sample configuration for quick testing.

### Step 2: Run Benchmark

#### Quick Start with Sample Data

```bash
# Run benchmark with sample data (small dataset for quick testing)
./test/benchmark \
--keys_file=sample/sample_keys.txt \
--keys_file_type=text \
--config_file_path=sample/sample_config.csv \
--init_num_keys=1000 \
--total_num_keys=2000 \
--batch_size=1000 \
--insert_frac=0.5 \
--thread_num=1 \
--print_batch_stats
```

#### Running with Large Datasets

```bash
./test/benchmark \
--keys_file=/path/to/your/dataset.csv \
--keys_file_type=text \
--config_file_path=generated_config.csv \
--init_num_keys=350000 \
--total_num_keys=700000 \
--print_batch_stats \
--insert_frac=0.5 \
--batch_size=200000 \
--thread_num=4 \
```

## Core Components

### libox.h - Core Library

The main header file contains the complete LiBox implementation with all core operations:

```cpp
#include "libox.h"
#include "libox_utils.h"

using namespace liboxns;

// Initialize LiBox with core functionality
TaskQueue splitQueue;
LiBox<uint64_t, uint64_t> index;
index.init(underflowThreshold, overflowThreshold, &splitQueue, thread_count);

// Load configuration (generated by partition_optimization or manual)
index.loadConfigByFile("config.csv");

// Core operations
index.insertKeyValue(key, value);           // Insert operation
auto result = index.searchKey(key);         // Point search
```

### libox_utils.h - Utility Functions

Contains utility functions for resegment partitioning and optimization algorithms used by the core library.

### partition_optimization.cpp - Configuration Generator

This tool analyzes your dataset characteristics and generates optimal segment configurations:

- Analyzes key distribution patterns
- Calculates optimal segment boundaries
- Determines appropriate box ranges for each segment
- Outputs optimized configuration file

## Architecture

LiBox employs a three-tier hierarchical structure with intelligent resegment capabilities:

```
┌─────────────────────────────────────────────────────────┐
│                      LiBox                              │
│                (with resegment support)                 │
├─────────────────────────────────────────────────────────┤
│  Segment 1    │  Segment 2    │  ...  │  Segment N      │
│  (adaptive)   │  (adaptive)   │       │  (adaptive)     │
├─────────────────────────────────────────────────────────┤
│  Box 1 │ Box 2│  Box 1 │ Box 2│       │  Box 1 │ Box 2  │
├─────────────────────────────────────────────────────────┤
│  OverflowKeyValue Arrays (when boxes are full)         │
└─────────────────────────────────────────────────────────┘
```

### Key Features

- **Adaptive Resegmentation**: Automatic segment splitting and merging based on load
- **Learned Index**: Linear interpolation for O(1) segment location
- **SIMD Optimization**: AVX-512 accelerated operations in all components
- **Concurrent Access**: Lock-free operations with atomic version control

## Benchmark Parameters

| Parameter             | Description                    | Example Values             |
| --------------------- | ------------------------------ | -------------------------- |
| `--keys_file`         | Path to input dataset file     | `sample/sample_keys.txt`   |
| `--keys_file_type`    | File format (text/binary)      | `text`                     |
| `--config_file_path`  | Path to segment configuration  | `sample/sample_config.csv` |
| `--init_num_keys`     | Initial number of keys to load | `1000000`                  |
| `--total_num_keys`    | Total keys in dataset          | `2000000`                  |
| `--batch_size`        | Operations per batch           | `10000`                    |
| `--insert_frac`       | Fraction of insert operations  | `0.5` (50% inserts)        |
| `--thread_num`        | Number of threads              | `4`                        |
| `--print_batch_stats` | Enable detailed statistics     | (flag)                     |

## Configuration File Format

The configuration file defines segments in CSV format (can be generated by partition_optimization tool):

```csv
lower_bound,upper_bound,box_range
0,10000,100
10001,50000,200
50001,100000,500
```

Each line specifies:

- **lower_bound**: Starting key value for the segment
- **upper_bound**: Ending key value for the segment
- **box_range**: Key range per box within the segment

## Sample Data Files

The `sample/` directory contains example files for quick testing:

### sample/sample_keys.txt

```
1
2
3
4
5
...
2000
```

### sample/sample_config.csv

```
0,500,50
501,1000,50
1001,2000,100
```

## Workflow Examples

### For New Datasets

1. **Analyze and Generate Configuration**:

   ```bash
   ./test/partition_optimization your_data.csv optimized_segment.csv
   ```

2. **Run Benchmark**:
   ```bash
   ./test/benchmark --keys_file=your_data.csv --config_file_path=optimized_segment.csv --keys_file_type=text --init_num_keys=1000000 --total_num_keys=2000000
   ```

### For Quick Testing

1. **Use Sample Data**:
   ```bash
   ./test/benchmark --keys_file=sample/sample_keys.txt --config_file_path=sample/sample_config.csv --keys_file_type=text --init_num_keys=1000 --total_num_keys=2000
   ```

## Performance Optimizations

- **SIMD Acceleration**: AVX-512 instructions for parallel operations
- **Cache-Friendly Layout**: 64-byte aligned data structures
- **Adaptive Resegmentation**: Dynamic load balancing
- **Lock-Free Operations**: Atomic version control for high concurrency
- **Intelligent Partitioning**: Data-driven segment optimization
